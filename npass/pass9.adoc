= Pass 9: Define words in forth

This defines the ":" word for defining new words.

Note that in this pass, we'll only be compiling "straightline"
definitions without conditions or loops.

== Tasks
- [x] Create Exit and ";"
- [x] Implement Compile word
- [x] Implement Literal_rt
- [x] Implement WDotColon for ":"
- [x] Revise STACK_ARGs to use function prologue/epilogue
- [x] Implement ExecuteColonDefinition



== Status
- Effort spent: 3.5h
- Effort left: 0h
- Initial estimate: 5h

== Log

=== Thursday, 05/14/2015
----
** 21:34 >> Implement Literal_rt with proper addressing

This is the rule for addressing

   displacement(base register, offset register, scalar multiplier)

For Literal_rt, what we want is the base register to be the entry
address, the offset register to the parameter index, the scalar
multiplier to be 8 and the displacement to be the offset into the
parameter field. Let's give this a try.


** 21:44 (10 min) Done implementing this
Let's compile and give it a try.

** 21:48 (14 min) Hah. Didn't actually define the entry
We need to do this in WColon. We also need to lea our
ExecuteColonDefinition function.

** 22:01 (27 min) The addressing worked

** 22:03 << (29 min) Was able to execute my new word!
It went to the default code for the Create entry. Let's take a break
and then implement ExecuteColonDefinition. After that, we should be
able to compile and execute words without conditions or loops.

** 22:19 Implement ExecuteColonDefinition
Was able to hook a new dictionary entry into it. Let's implement the
function next.


** 22:30 >> Let's start implementing this

** 22:36 (6 min) This may be a little delicate
I think we may need to use the base pointer? When
ExecuteColonDefinition is called, the stack looks like this:

   return address
   entry address (first stack arg)

We start by pushing the first parameter index after this:

   0
   return address
   entry address (first stack arg)


** 22:46 (16 min) Hmmm...may need to do function prologue/epilogue in all cases
This will make STACK_ARG_1, etc consistent.

** 22:49 << (19 min) Let's do this tomorrow. I'll update pass9.
----


=== Friday, 05/15/2015
----
** 22:15 >> Let's make sure we use function prologue/epilogues

** 22:27 (12 min) Added prologue/epilogue

** 22:33 (18 min) Used MPrologue/MEpilogue in Exit
Let's grep for other uses of Stack Args and use the prologue/epilogue

** 22:41 (26 min) Looks good. Let's check in.

** 22:44 (29 min) Let's take another look at ExecuteColonDefinition

** 23:29 << (84 min) OK, I think this is working
Let's step through it tomorrow.
----


=== Saturday, 05/16/2015
----
** 05:45 >> Execute colon definition
** 06:43 << (58 min) Got a colon definition to execute!
I had to figure out a couple of things:
   * Special functions should be executed directly
   * You shouldn't try to reach back into previous stack frames. In
     this case I knew the address of the colon definition was on the
     stack, and I wanted to use it, but it was on the stack in the
     previous stack frame. To do this properly, I had to push this
     onto the stack as a standard stack argument.
----