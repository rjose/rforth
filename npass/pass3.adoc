= Pass 3: Search for words in dictionary

== Tasks
- [x] Spec out dictionary
- [x] Initialize dictionary with some entries
- [x] Search for an entry
- [x] Implement param stack



== Status
- Effort spent: 5h
- Effort left: 0h
- Initial estimate: 16h

== Log

=== Sunday, 04/26/2015

----
** 07:15 >> Spec out dictionary

** 07:37 (22 min) Described each part of an entry
Not sure how the execution part should work with the code pointers. Is
this the same as calling a function, or is there something more subtle
going on?

** 07:39 (24 min) I don't think we can just call a function
Well, I think we might be able to push the address of the next
instruction onto the assembly stack and so after returning from
executing the first step in a definition, the next step will be
called. 

** 07:50 (35 min) Actually, I do think we can just call a function
The mechanisms described in Starting Forth are really what happens
when we do a "call" and "ret" in assembly. The assembly stack is
really the return stack in forth.

** 07:57 (42 min) To execute a word, we need its parameter field address
When we find a word, we know its parameter field address (+24), so we
can pass this on the assembly stack and call the code at +16.

** 08:08 << (53 min) Redid dictionary layout a bit

** 08:11 Break
After a break, we should declare the dictionary in the BSS section of
the rforth file and then add some functions to manipulate and search
it. We should know what the max size of the dictionary is and abort if
we exceed that.

** 13:02 Study the CREATE description in Starting Forth
There seems to be a little subtelty here. Let's see if we can make out
how it should work and then implement it.

** 16:01 The IMMEDIATE word is like a macro
Making a word immediate means that it executes during the compilation
of a word (i.e., when it's being defined). The results of the word are
compiled into the definition.

** 16:10 When do we advance dp and pfa?
I can create a header in the current dictionary entry, but we can't
really advance the pointers until we know how many parameters we
have. Maybe we should initialize dp and pfa to 0 and then when we
create an entry, we use the current dp as the link, fill out the
header and then advance dp and pfa. At that point, pfa can be advanced
as much as we need.

** 16:14 Actually, do we need pfa?
If pfa is always the next parameter field and that is also where the
next dictionary entry will be added, then this is the same as
dp. Hmmm...this isn't correct. The dp pointer should really be
pointing to the last dictionary entry. This is the starting point for
a word search. The pfa should be the next dictionary cell, which may
be another parameter or which may be a new dictionary entry. Yes, we
need both.



** 19:05 Make read_word zero the first 4 bytes of tib
This will ensure that words less than 4 chars will match properly in
the register.

** 19:26 >> Implement create
This creates a new dictionary entry.

** 20:46 << (80 min) Figured out how to get the address of a function
I believe create is done. Let's check in and then rewrite all files
and functions using a capitalization convention.

** 21:45 >> Add a check that we don't exceed the dictionary limits

** 21:53 (8 min) Done adding check

** 21:53 (8 min) Update naming convention
Let's rename our files first and then the function names.

** 21:55 (10 min) Done naming files
Now, let's go file-by-file and rename the functions.

** 22:05 << (20 min) Done renaming functions

----

=== Monday, 04/27/2015

----
** 21:55 >> Search for an entry
I've spec'd this out, so let's try implementing it.

** 22:01 (6 min) What's the difference between the Tick word and its runtime?
Is there a lower level search function I should implement? When "Tick"
is compiled, what goes into its code pointer? It seems like its own
self should go there.

** 22:38 (37 min) Created Tick function
Need to add PushData, but I think we can test it.

** 23:14 << (74 min) Debugged and looks good
----

=== Tuesday, 04/28/2015

----
** 19:15 >> Spec out PushParam
Let's describe how to implement a PushParam function for pushing items
on our param stack.

** 20:03 << (48 min) Spec'd it out
Also checked Create. Also added space for param stack.

** 21:17 >> Implement PushParam

** 21:30 (13 min) Implementing it. Let's give it a try

** 21:49 << (32 min) Looks good
Let's check in
----