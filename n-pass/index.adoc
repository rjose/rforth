= n-pass index
rforth development passes

* [x] Pass 1: Build an assembly language program
* [x] Pass 2: Collect input into a line buffer
* [x] Pass 3: Write a next word function
* [ ] Pass 4: Start over with getc
* [ ] Pass : Create a dictionary with lookup
* [ ] Pass : Execute routine from dictionary

What are the registers?

EAX Accumulator/results
EBX Pointer into data segment
ECX Counter
EDX I/O pointer
EDI Destination pointer
ESI Source pointer
ESP Stack pointer
EBP Base pointer

How should all of this work? It seems like we need to parse out words
from an input buffer. Moore seems to recommend putting those in some
word aligned area. Once you have a word there, you search for it in
the dictionary. What goes into the dictionary? The keys to this
dictionary are the verbs. The values are variable length containing
the following info: name, next, code to execute, and parameters.

The name field should be aligned with spaces for padding. The "next"
link should be immediately after this. An address of a routine to call
is next. Finally, is a parameter section with a number, an array to
store data, an array of dictionary entries.

We need to be able to add an entry and search for an entry.

If we have 32 bit registers, we will should align words on these
boundaries. What's an appropriate length for a word?
"read_input_buffer_from_host" is 27 characters long. For 32 bit (4
bytes), this will take 7 words (the last character should be
\0). Let's use this.

The link will point to the previous entry. How does this all start? We
should have some chunk of space for the dictionary. We should know the
location of the latest entry (should point to the beginning of the
dictionary). We should make sure the link for the first entry is NULL.

== Passes
include::pass1/pass1.adoc[leveloffset=+2]

